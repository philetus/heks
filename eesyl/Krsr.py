class Krsr:
    """krsr to draw to eesyl

       a path can be generated by using move_*() and path_*() commands

       move_to() and path_to() take absolute coordinates from the upper
       right corner of the canvas, and move_by() and path_by() take coordinates
       relative to the current krsr position

       moving krsr after path segments have been drawn initiates a new subpath

       two types of paths can be generated depending on which args are given:
         > a straight path from the current krsr coords to the given coords
         > a bezier curve from the current krsr coords to the given coords,
           using two additional control point coords to set the curvature

       generated paths can be stroked (with the current krsr color, size and
       shape) using stroke(), or can be filled (with the current
       krsr color) using fill()
    """

    # brush shape flags
    SQUARE = 0
    ROUND = 1

    def __init__(self, context):
        # cairo context to draw to
        self._context = context

    def move_to(self, y, x):
        """move krsr to given coordinates
        """
        self._context.move_to(y, x)

    def move_by(self, dy=0.0, dx=0.0):
        """move krsr relative to current position by given delta coordinates
        """
        self._context.rel_move_to(dy, dx)

    def path_to(self, y, x, c0_y=None, c0_x=None, c1_y=None, c1_x=None):
        """generate path to absolute coords (y, x[, c0_y, c0_x, c1_y, c1_x])

           > if only (y, x) coords are given generates a straight path
           > if control points are given generates a bezier curve
        """

        # if control points given generate bezier curve
        if self._vet_control_points(c0_x, c0_y, c1_x, c1_y):
            self._context.curve_to(c0_x, c0_y, c1_x, c1_y, x, y)

        # otherwise generate straight path
        else:
            self._context.line_to(y, x)

    def path_by(self, dy, dx, c0_dy=None, c0_dx=None, c1_dy=None, c1_dx=None):
        """generate to relative coords (dy, dx[, c0_dy, c0_dx, c1_dy, c1_dx])

           > if only (dy, dx) coords are given generates a straight path
           > if control points are given generates a bezier curve
        """

        # if control points given generate bezier curve
        if self._vet_control_points(c0_dx, c0_dy, c1_dx, c1_dy):
            self._context.rel_curve_to(c0_dx, c0_dy, c1_dx, c1_dy, dx, dy)

        # otherwise generate straight path
        else:
            self._context.rel_line_to(dy, dx)

    def close_path(self):
        """joins beginning and end of current subpath so that they will be
           stroked smoothly, adding a new path segment if the first and
           last points are not the same
        """
        self._context.close_path()
        
    def fill_path(self):
        """fill current path with current brush settings
        """
        self._context.fill_preserve()

    def stroke_path(self):
        """stroke current path with current brush settings
        """
        self._context.stroke_preserve()

    def clear_path(self):
        """clear current path
        """
        self._context.new_path()
    
    def wipe(self):
        """wipe screen by filling window with current color
        """
        self._context.paint()
    
    def push(self):
        """push current state to stored state stack
        """
        self._context.save()
    
    def pop(self):
        """pop last pushed state off of state stack
        """
        self._context.restore()
    
    def transform(self, matrix):
        """applies given matrix to current krsr transform
        """
        self._context.transform(matrix)
    
    def translate(self, ty, tx):
        """applies translation matrix to current krsr transform
        """
        self._context.translate(ty, tx)
    
    def scale(self, sy, sx):
        """applies scale matrix to current krsr transform
        """
        self._context.scale(sy, sx)
    
    def rotate(self, radians):
        """applies rotation matrix to current krsr transform
        """
        self._context.rotate(radians)
        
    @staticmethod
    def _vet_control_points(x0, y0, x1, y1):
        """check if path should be curved
           
           return true if all four control points are given, false if none
           are given and raise a value error if partial list is given
           if control points are given generate bezier curve
        """
        if( (x0 is None) and (y0 is None) and
            (x1 is None) and (y1 is None) ):
            return False
        
        if( (x0 is None) or (y0 is None) or
            (x1 is None) or (y1 is None) ):
            raise ValueError(
                "can't generate path: some but not all control points given" )

        return True

    def set_color(self, r, g, b, a=1.0):
        self._context.set_source_rgba(r, g, b, a)

    def set_size(self, pixels):
        self._context.set_line_width(pixels)

    def get_size(self):
        return self._context.get_line_width()

    def get_position(self):
        y, x = self._context.get_current_point()
        return y, x
    
    def set_shape(self, shape):
        raise NotImplementedError

